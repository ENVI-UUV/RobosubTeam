
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>SimBox - Robosub Simulator</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #000;
				font-family:Monospace;
				font-size:13px;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				text-align:center;
				padding: 5px;
			}
			
			#inset  {
				width: 200px;
				height: 200px;
				background-color: #fff; /* or transparent; will show through only if renderer alpha: true */
				border: 1px solid black; /* or none; */
				margin: 20px;
				padding: 0px;
				position: absolute;
				left: 0px;
				bottom: 0px;
    				z-index: 100;
			}

                        


			#inset2  {
				width: 200px;
				height: 200px;
				background-color: transparent; /* or transparent; will show through only if renderer alpha: true */
				border: 1px solid black; /* or none; */
				margin: 20px;
				padding: 0px;
				position: fixed;
				left: 1120px;
				bottom: 0px;
    				z-index: 100;
			}


			a {

				color: #000000;
			}

		</style>
	</head>
	<body>

		<div id="info"><a href="https://github.com/cantren/cantren.github.io/" target="_blank">Code</a></a> - Please "fork" as this page changes often.</div>
		<div id="container">
		<div id="inset">
		<script src="../js/three.min.js"></script>


		<script src="../js/FirstPersonControls.js"></script>
		<script src="../js/KeyboardState.js"></script>
		<script src="../js/Mirror.js"></script>
		<script src="../js/WaterShader.js"></script>

		<script src="../js/Detector.js"></script>
		<script src="../js/stats.min.js"></script>
		
		<script src="../js/josdirksen/dat.gui.js"></script> 

		<script src="js/MTLLoader.js"></script>
		<script type="text/javascript" src="js/OBJMTLLoader.js"></script>


  		<div id='inset2'>
		<object width="200" height="200"><param name="movie" value="http://127.0.0.1:8090/simbox.swf">
		<embed src="http://127.0.0.1:8090/simbox.swf" width="200" height="200">
		</embed></object></div>

		

		<script>

			if ( ! Detector.webgl ) {

				Detector.addGetWebGLMessage();
				document.getElementById( 'container' ).innerHTML = "";

			}

			var container, container2, stats;//cargo cult code comment out this line please(may be desired in future)
			var camera, camera2, camControls, camControls2, scene, scene2, renderer, renderer2;//these are actually usefull
			var sphere;//cargo cult code delete this line please
			var CANVAS_WIDTH = 200,
			    CANVAS_HEIGHT = 200,
			    CAM_DISTANCE = 300;
			
			
			var clock = new THREE.Clock();//I spent a long time debugging because I forgot to initialize this
			var keyboard = new KeyboardState();
			

			var parameters = {
				width: 2000,
				height: 2000,
				widthSegments: 250,
				heightSegments: 250,
				depth: 1500,
				param: 4,
				filterparam: 1
			}
			
			var waterNormals;

			init();
			animate();

			function init() {
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				
				container2 = document.getElementById('inset');
				// renderer
				renderer2 = new THREE.WebGLRenderer();
				renderer2.setClearColor( 0xf0f0f0, 1 );
				renderer2.setSize( CANVAS_WIDTH, CANVAS_HEIGHT );
				container2.appendChild( renderer2.domElement );


				scene = new THREE.Scene();
				scene2 = new THREE.Scene();
				
				//add water colored fog
				//scene.fog = new THREE.FogExp2( 0x008080, 0.1875 );
				
				//scene.fog = new THREE.FogExp2( 0x008080, 0.1375 );
				scene.fog = new THREE.FogExp2( 0x008080, 0.1875 );
				scene2.fog = new THREE.FogExp2( 0x008080, 0.1875 );
				//scene.fog = new THREE.FogExp2( 0x008080, 0.05 );
				//scene2.fog = new THREE.FogExp2( 0x008080, 0.05 );
				
				camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.5, 3000000);
				
				camera.position.x = 0.0;//pool line of symetry is x axis
        			camera.position.y = -2.0;//water depth
			        camera.position.z = -28.0;//how close to the wall are you
			        camera.rotation.z = 3.06;
			        
			        camera2 = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.5, 3000000);
			        camera2.up = camera.up; // important!
			        
			        camera2.position.x = 0.0;//pool line of symetry is x axis
        			camera2.position.y = -2.0;//water depth
			        camera2.position.z = -28.0;//how close to the wall are you
			        camera.rotation.z = 3.06;
				//camera.position.set( 0, -2, -28 );
        			
        			camControls = new THREE.FirstPersonControls( camera, renderer.domElement );
        			camControls.lookSpeed = 0.05; //Pitch Thrust to drag ratio
        			camControls.movementSpeed = 0.25; // FWD BKWD Thrust to drag ratio 
        			camControls.verticalMin = -50.0; //basement floor level
        			camControls.verticalMax = 10.0; //sky ceiling level
        			
        			camControls2 = new THREE.FirstPersonControls( camera2, renderer2.domElement );
        			camControls2.lookSpeed = 0.05; //Pitch Thrust to drag ratio
        			camControls2.movementSpeed = 0.25; // FWD BKWD Thrust to drag ratio 
        			camControls2.verticalMin = -50.0; //basement floor level
        			camControls2.verticalMax = 10.0; //sky ceiling level
        			
        			
				//Add scene lighting
				var light = new THREE.HemisphereLight( 0xffffbb, 0x008080, 1 );//I tried changing the light color here to see what would happen
				light.position.set( - 1, 1, - 1 ); //my hemisphere flipped upside down
				scene.add( light );//I changed the name to distinguish a negative y value from "sunlight"

				var light2 = new THREE.HemisphereLight( 0xffffbb, 0x008080, 1 );//I tried changing the light color here to see what would happen
				light2.position.set( - 1, 1, - 1 ); //my hemisphere flipped upside down
				scene2.add( light2 );//I changed the name to distinguish a negative y value from "sunlight"
				
				//More scene lighting
				var ambientLight = new THREE.AmbientLight(0x383838);
        			scene.add(ambientLight);
        			
        			var ambientLight2 = new THREE.AmbientLight(0x383838);
				scene2.add(ambientLight2);
				
        			// add spotlight for the shadows
        			var spotLight = new THREE.SpotLight(0xffffff);
        			spotLight.position.set(100, 140, 130);
        			spotLight.intensity = 2;
        			scene.add(spotLight);
        			
        			var spotLight2 = new THREE.SpotLight(0xffffff);
        			spotLight2.position.set(100, 140, 130);
        			spotLight2.intensity = 2;
        			scene2.add(spotLight2);


				//load and insert the obj meshes and mtl textures
				//the "secret sauce" is in these .obj and .mtl files.
				var loader = new THREE.OBJMTLLoader(); //this object does the work
				loader.load('../obj/transdec OBJ/transdec test.obj', '../obj/transdec OBJ/transdec test.mtl', function ( object ) {
					object.position.y = -12.975;//experimentally generated via trial and error
					scene.add( object );//to make a Robosub you would likely need to change it's name from "object"
					});
        			loader.load('../obj/robosub obstacles/obstacles.obj', '../obj/robosub obstacles/obstacles.mtl', function ( object ) {
					object.position.y = -12.975;//experimentally generated via trial and error
					scene.add( object );//to make a Robosub you would likely need to change it's name from "object"
					});
				loader.load('../obj/transdec OBJ/transdec test.obj', '../obj/transdec OBJ/transdec test.mtl', function ( object ) {
					object.position.y = -12.975;//experimentally generated via trial and error
					scene2.add( object );//to make a Robosub you would likely need to change it's name from "object"
					});
        			loader.load('../obj/robosub obstacles/obstacles.obj', '../obj/robosub obstacles/obstacles.mtl', function ( object ) {
					object.position.y = -12.975;//experimentally generated via trial and error
					scene2.add( object );//to make a Robosub you would likely need to change it's name from "object"
					});

				waterNormals = new THREE.ImageUtils.loadTexture( 'textures/waternormals.jpg' ); //potential for easy modification/obstacle reflections
				waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping; //recycle that .jpg like a TV re-run
				//initialize/declare water shader and provide parameters
				water = new THREE.Water( renderer, camera, scene, { //three.js has a specific thing for water, this is it
					textureWidth: 512, //size of waves I think, maybe the waternormals.jpg stretch?
					textureHeight: 512, //size of waves I think, maybe the waternormals.jpg stretch?
					waterNormals: waterNormals, //provides the .jpg Texture
					alpha: 	0.925, //how transparent is the water?
					//sunDirection: new THREE.Vector3( 0.70707, -0.70707, 0 ), 
					sunDirection: light.position.clone().normalize(), // I think this makes the reflection normal to the texture
					sunColor: 0xffffff, //Light has to hit the water, what color is it?
					waterColor: 0xe7e7ec,//,0x000000,//0x001e0f,//0xe7e7ec,//0x001e0f,//water color for different effects
					distortionScale: 50.0, //also related to size of waves?
					fog: true,
				});

				//initialize/declare new planes for holding the "water" texture mapping
				mirrorMesh = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( parameters.width * 500, parameters.height * 500 ),
					water.material
				);
				mirrorMesh2 = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( parameters.width * 500, parameters.height * 500 ),
					water.material
				);
				/*
				mirrorMesh3 = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( parameters.width * 500, parameters.height * 500 ),
					water.material
				);
				mirrorMesh4 = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( parameters.width * 500, parameters.height * 500 ),
					water.material
				);
				*/

				
				mirrorMesh.add( water ); //add water shader to otherwise boring underwater PlaneBufferGeometry
				mirrorMesh2.add( water ); //add water shader to otherwise boring PlaneBufferGeometry
				//mirrorMesh3.add( water ); //add water shader to otherwise boring underwater PlaneBufferGeometry
				//mirrorMesh4.add( water ); //add water shader to otherwise boring PlaneBufferGeometry
				mirrorMesh.rotation.x = - Math.PI * 1.5; //rotate undwater water surface to point down
				mirrorMesh2.rotation.x = - Math.PI * 0.5; //rotate water surface to point up
				mirrorMesh.position.y = -0.85;//water height experimentally generated via trial and error
				mirrorMesh2.position.y = -0.9;//water height experimentally generated via trial and error
				
				//mirrorMesh3.rotation.x = - Math.PI * 1.5; //rotate undwater water surface to point down
				//mirrorMesh4.rotation.x = - Math.PI * 0.5; //rotate water surface to point up
				//mirrorMesh3.position.y = -0.85;//water height experimentally generated via trial and error
				//mirrorMesh4.position.y = -0.9;//water height experimentally generated via trial and error
				
				scene.add( mirrorMesh ); //add underwater water surface
				scene.add( mirrorMesh2); //add water surface
				//scene.add( mirrorMesh3 ); //add underwater water surface
				//scene.add( mirrorMesh4); //add water surface
				//scene2.add( mirrorMesh ); //add underwater water surface
				//scene2.add( mirrorMesh2); //add water surface 

				// load skybox &/or (start example code copypasta: http://threejs.org/examples/#webgl_shaders_ocean)
				var cubeMap = new THREE.CubeTexture( [] );//initialize/declare the texture object to be mapped to the skybox mesh var skyBox = new THREE.Mesh
				cubeMap.format = THREE.RGBFormat;//don't know or care
				cubeMap.flipY = false;//if you make this true the walls of the box go below the horizon

				
				var loader = new THREE.ImageLoader();
				loader.load( '../textures/skyboxsun25degtest.png', function ( image ) {

					var getSide = function ( x, y ) {

						var size = 1024;

						var canvas = document.createElement( 'canvas' );
						canvas.width = size;
						canvas.height = size;

						var context = canvas.getContext( '2d' );
						context.drawImage( image, - x * size, - y * size );

						return canvas;

					};

					cubeMap.images[ 0 ] = getSide( 2, 1 ); // px
					cubeMap.images[ 1 ] = getSide( 0, 1 ); // nx
					cubeMap.images[ 2 ] = getSide( 1, 0 ); // py
					cubeMap.images[ 3 ] = getSide( 1, 2 ); // ny
					cubeMap.images[ 4 ] = getSide( 1, 1 ); // pz
					cubeMap.images[ 5 ] = getSide( 3, 1 ); // nz
					cubeMap.needsUpdate = true;

				} );
				//var cubeMap2 = new THREE.CubeTexture( [] );//initialize/declare the texture object to be mapped to the skybox mesh var skyBox = new THREE.Mesh
				//cubeMap2.format = THREE.RGBFormat;//don't know or care
				//cubeMap2.flipY = false;//if you make this true the walls of the box go below the horizon

				//var loader2 = new THREE.ImageLoader();
				//loader2.load( '../textures/skyboxsun25degtest.png', function ( image2 ) {


				//	var getSide2 = function ( x, y ) {

				//		var size = 1024;

				//		var canvas2 = document.createElement( 'canvas2' );
				//		canvas2.width = size;
				//		canvas2.height = size;

				//		var context2 = canvas2.getContext( '2d' );
				//		context2.drawImage( image2, - x * size, - y * size );

				//		return canvas2;

				//	};

				//	cubeMap2.images[ 0 ] = getSide2( 2, 1 ); // px
				//	cubeMap2.images[ 1 ] = getSide2( 0, 1 ); // nx
				//	cubeMap2.images[ 2 ] = getSide2( 1, 0 ); // py
				//	cubeMap2.images[ 3 ] = getSide2( 1, 2 ); // ny
				//	cubeMap2.images[ 4 ] = getSide2( 1, 1 ); // pz
				//	cubeMap2.images[ 5 ] = getSide2( 3, 1 ); // nz
				//	cubeMap2.needsUpdate = true;

				//} );
				//Initialize/declare the shader for the skybox
				var cubeShader = THREE.ShaderLib['cube'];
				cubeShader.uniforms['tCube'].value = cubeMap;
				
				//var cubeShader2 = THREE.ShaderLib['cube'];
				//cubeShader2.uniforms['tCube'].value = cubeMap2;
				
				//Create skybox material 
				var skyBoxMaterial = new THREE.ShaderMaterial( {
					fragmentShader: cubeShader.fragmentShader,
					vertexShader: cubeShader.vertexShader,
					uniforms: cubeShader.uniforms,
					depthWrite: false,
					side: THREE.BackSide
				});
				//var skyBoxMaterial2 = new THREE.ShaderMaterial( {
				//	fragmentShader: cubeShader2.fragmentShader,
				//	vertexShader: cubeShader2.vertexShader,
				//	uniforms: cubeShader2.uniforms,
				//	depthWrite: false,
				//	side: THREE.BackSide
				//});

				//Create Mesh to map skybox material on to
				var skyBox = new THREE.Mesh(
					new THREE.BoxGeometry( 10000, 10000, 10000 ),
					skyBoxMaterial
				);
				//var skyBox2 = new THREE.Mesh(
				//	new THREE.BoxGeometry( 10000, 10000, 10000 ),
				//	skyBoxMaterial2
				//);
				scene.add( skyBox ); //create Point Loma Sky
				//scene2.add( skyBox2 ); //create Point Loma Sky

//				var skyBox2 = new THREE.Mesh(
//					new THREE.BoxGeometry( 10000, 10000, 10000 ),
//					skyBoxMaterial2
//				);

				//var skyBox2 = new THREE.Mesh(
				//	new THREE.BoxGeometry( 10000, -10000, 10000 ),
				//	skyBoxMaterial
				//);
//				scene.add( skyBox2 );


			}

			//source:http://www.smartjava.org/ltjs/chapter-09/02-selecting-objects.html
			var controls = new function () {
			            this.fogDensity = 0.1875;
        			    this.lookSpeed = 0.03;
        			    this.movementSpeed = 0.03;
        			    this.xPosition = 0.0;
        			    this.yPosition = -2.0;
        			    this.zPosition = -28.0;
        			    this.randomPosHead = false;
        			    this.getlost = function(){
        			    	camera2.position.x = (Math.floor((Math.random() * 90) + 1));camera.position.x = Math.floor((Math.random() * 90) + 1); camera2.position.x -=45; camera.position.x -=45;
        			    	camera2.position.y = ((Math.floor((Math.random() * 55) + 1))/10);camera.position.y = ((Math.floor((Math.random() * 55) + 1))/10); camera2.position.y -=11; camera.position.y -=11;
        			    	camera2.position.z = (Math.floor((Math.random() * 90) + 1));camera.position.z = Math.floor((Math.random() * 90) + 1); camera2.position.z -=45; camera.position.y -=45;
               			    	camera2.rotation.z = ((Math.floor((Math.random() * (Math.PI*200)) + .1))/100);camera.rotation.z = ((Math.floor((Math.random() * (Math.PI*200)) + .1))/100); camera2.rotation.z -= Math.PI; camera.rotation.y -= Math.PI ;
        			    };
        			    //this.waterchop = 60.0;
        			}
        		

        		var gui = new dat.GUI({resizable : false});
        		//gui.add(init, 'fogDensity', 0, 0.25);
        		//gui.add(controls, 'fogDensity', 0, 0.25);
        		var folder1 = gui.addFolder('fog');
        		var fogDensity = folder1.add(scene2.fog, 'density').min(0.00).max(0.75).step(0.01).listen();
        		var folder2 = gui.addFolder('behavior');
        		var rotSpeed = folder2.add(camControls2, 'lookSpeed').min(0.0).max(0.5).step(0.01).listen();
        		var movSpeed = folder2.add(camControls2, 'movementSpeed').min(0.0).max(5.0).step(0.01).listen();
        		//gui.add(controls, 'lookSpeed', 0, 0.5);
        		//gui.add(controls, 'movementSpeed', 0, 0.5);
        		//gui.add(camera2.position, 'x', -50, 50).listen();
        		//gui.add(controls, 'xPosition', -50, 50);
        		//gui.add(controls, 'yPosition', -50, 50);
        		//gui.add(controls, 'zPosition', -50, 50);
        		//source:http://www.smartjava.org/ltjs/chapter-09/02-selecting-objects.html
        		var folder3 = gui.addFolder('position');
  			var posX = folder3.add( camera2.position, 'x' ).min(-50.00).max(50.00).step(0.01).listen();
  			var posY = folder3.add( camera2.position, 'y' ).min(-50.00).max(50.00).step(0.01).listen();
  			var posZ = folder3.add( camera2.position, 'z' ).min(-50.00).max(50.00).step(0.01).listen();
  			//var rPos = folder3.add( controls.randomPosition );
  			
  			var folder4 = gui.addFolder('rotation');
  			var rotZ = folder4.add( camera.rotation, 'z' ).min(-5.00).max(5.00).step(0.01).listen();
  			//var rHead = folder4.add( controls.randomHeading );
  			
  			var folder5 = gui.addFolder('confusion');
  			var rPosHead = gui.add(controls, 'getlost');
  			
  			//var folder4 = gui.addFolder('wavespeed');
  			//var folder5 = gui.addFolder('wavesize');
  			//folder5.add( water, 'textureWidth' ).min(0.00).max(512.00).step(0.1).listen();
  			//folder5.add( water, 'textureHeight' ).min(0.00).max(512.00).step(0.1).listen();
  		
  			posX.onChange(function(value) 
  			{   camera2.position.x = value; camera.position.x = value;   });
  			posY.onChange(function(value) 
  			{   camera2.position.y = value; camera.position.y = value;   });
			posZ.onChange(function(value) 
			{   camera2.position.z = value; camera.position.z = value;   });
			rotZ.onChange(function(value) 
			{   camera.rotation.z = value; camera.rotation.z = value;   });
			//source:http://nuevil.com/index3.html
			//source: http://hotblocks.nl/tests/three/dat.gui.html
			fogDensity.onChange(function(value) 
  			{   scene2.fog.density = value; scene.fog.density = value;   });
  			rotSpeed.onChange(function(value) 
  			{   camControls2.lookSpeed = value; camControls.lookSpeed = value;   });
			movSpeed.onChange(function(value) 
			{   camControls2.movementSpeed = value; camControls.movementSpeed = value;  });
			movSpeed.onChange(function(value) 
			{   camControls2.movementSpeed = value; camControls.movementSpeed = value;  });
			
			


			//

			function animate() {

				requestAnimationFrame( animate ); //animate the frame
				render(); //render the frame
				

			}

			function render() {
				keyboard.update();
				camControls.update( clock.getDelta() ); //update First Person Camera
				camControls2.update( clock.getDelta() ); //update First Person Camera
				camera2.position.copy( camera.position );
				camera2.rotation.copy( camera.rotation );
				camera2.up = new THREE.Vector3(-1,-1,-1);
				camera2.rotateX(Math.PI/-2);
				camera2.rotateZ((Math.PI/-2));
				//controls['zPosition'] = camera2.position.z;
				
				//camera2.rotateY(Math.PI/-1);
				//camera2.up = new THREE.Vector3(0,-1,0);
				//camera2.lookAt(new THREE.Vector3(-1, -1, -1));
				//camera2.rotation.y = Math.PI;
				camera2.rotateZ(Math.PI/2);
				
				var time = performance.now() * 0.001; //Measure time for water
				//var waterchop = 60.0;
				//gui.folder4.add( render, 'waterchop' ).min(0.00).max(100.00).step(0.01);
				//water.material.uniforms.time.value += 1.0 / waterchop; //speed of water motion(wind chop)
				water.material.uniforms.time.value += 1.0 / 60.0; //speed of water motion(wind chop)
				water.render(); //render water surface
				
				//scene.fog.density = controls.fogDensity;
				//scene2.fog.density = controls.fogDensity;
				
				if ( keyboard.pressed("shift") )
					camControls2.movementSpeed = camControls2.movementSpeed += 0.5;
				if ( keyboard.pressed("ctrl") )
					camControls2.movementSpeed = camControls2.movementSpeed -= 0.5;

				if ( keyboard.pressed("E") ) {
					camera2.rotateY(Math.PI/-1);
					//camera2.rotate
					camera2.rotateZ((Math.PI)/-1);
				}
				if ( keyboard.pressed("J") ) {controls.getlost();}

				renderer.render( scene, camera ); //render everything else
				//scene2.applyMatrix(new THREE.Matrix4().makeScale(-1, 1, 1));
				renderer2.render( scene2, camera2 );

			}
/*
#inset3  {
                                width: 728px;
                                height: 728px;
				background-color: transparent;
                                border: 1px solid black;
                                margin: 20px;
                                padding: 0px;
                                position: fixed;
                                right: 298px;
                                bottom: 0px;
                                z-index: 200;
                        }
*/
		</script>
	</body>
</html>
